package pro.sky.questionsforexam.repository;

import pro.sky.questionsforexam.model.Question;

import javax.annotation.PostConstruct;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

public class JavaQuestionRepository implements QuestionRepository {

    private static final Set<Question> questions = new HashSet<>();

    @PostConstruct
    public static void init() {
        questions.add(new Question("Какие особенности есть у Java?","1.ООП: наследование, инкапсуляция, полиморфизм, абстракция. 2. Кроссплатформенность. 3. Высокая производительность. 4.Мультипоточность."));
        questions.add(new Question("Что такое наследование?","Под наследованием подразумевается, что один класс может наследовать другой класс. Таким образом можно переиспользовать код с класса, от которого наследуются."));
        questions.add(new Question("Что такое инкапсуляция?","Инкапсуляция — это сокрытие реализации при помощи модификаторов доступа, при помощи геттеров и сеттеров."));
        questions.add(new Question("Что такое полиморфизм?","Полиморфизм — это способность программы идентично использовать объекты с одинаковым интерфейсом."));
        questions.add(new Question("Что такое конструктор в Java?","Конструктор похож на метод. Его особенность заключается в том, что нет возвращающего элемента (в том числе и void), а его имя совпадает с именем класса. Если не пишется никакого конструктора явно, пустой конструктор будет создан автоматически."));
        questions.add(new Question("Какие два класса не наследуются от Object?","Все классы прямо или через предков наследуются от класса Object!"));
        questions.add(new Question("Что такое Local Variable?","Local variable — это переменная, которая определена внутри метода и существует вплоть до того момента, пока выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать."));
        questions.add(new Question("Что такое Instance Variable?","Instance Variable — переменная, которая определена внутри класса, и она существует вплоть до того момента, пока существует объект."));
        questions.add(new Question("Перечислите модификаторы доступа","1. private — используется для методов, полей и конструкторов. Уровень доступа — только класс, внутри которого он объявлен. 2. package-private(default) — может использоваться для классов. Доступ только в конкретном пакете (package), в котором объявлен класс, метод, переменная, конструктор. 3. protected — такой же доступ, как и package-private + для тех классов, которые наследуются от класса с модификатором protected. 4. public — используется и для классов. Полноценный доступ во всем приложении."));
        questions.add(new Question("Что такое переопределение (overriding) методов?","Переопределение методов происходит, когда child хочет изменить поведение parent класса. Требования, которые нужно соблюдать: сигнатура метода должна быть такая же; возвращаемое значение должно быть таким же."));
        questions.add(new Question("Что такое сигнатура метода?","Сигнатура метода — это набор из названия метода и аргументов, какие принимает метод."));
        questions.add(new Question("Что такое перегрузка методов?","Перегрузка методов — это свойство полиморфизма, в котором при помощи изменения сигнатуры метода можно создать разные методы для одних действий: одно и то же имя метода; разные аргументы; может быть разный возвращаемый тип."));
        questions.add(new Question("Что такое абстрактные методы и классы?","У абстрактного класса есть несколько особенностей: на его основе нельзя создать объект; он может иметь абстрактные методы; он может и не иметь абстрактные методы. Абстрактные классы нужны для обобщения какой-то абстракции, которой в реальной жизни нет, но она содержит множество общих поведений и состояний (то есть, методов и переменных)."));
        questions.add(new Question("Почему доступ по элементу в массиве происходит за O(1)?","При создании массива известен его тип.Если известен тип, то понятно, какого размера будет каждая ячейка массива. Известно, какого размера будет массив. Из этого следует: чтобы понять, в какую ячейку записать, нужно просто вычислить, в какую область памяти записать."));
        questions.add(new Question("Что такое ключевое слово final и где его использовать?","Ключевое слово final можно использовать для переменных, методов и классов. final переменную нельзя переназначить на другой объект. final класс бесплоден, у него не может быть наследников. final метод не может быть переопределен у предка."));
        questions.add(new Question("Можно ли считать Final переменную константой?","Поскольку у нас не получится присвоить новое значение для final переменной, кажется, что это переменные константы. Но это только на первый взгляд. Если тип данных, на который ссылается переменная —  immutable, то да, это константа. А если тип данных mutable, то есть изменяемый, при помощи методов и переменных можно будет изменить значение объекта, на который ссылается final переменная, и в таком случае назвать ее константой нельзя."));
        questions.add(new Question("Что такое mutable immutable?","Mutable называются объекты, чьи состояния и переменные можно изменить после создания. Например такие классы, как StringBuilder, StringBuffer. Immutable называются объекты, состояния и переменные которых нельзя изменить после создания объекта. Чем не отличный ключ для HashMap, да?) Например, String, Integer, Double и так далее."));
        questions.add(new Question("Как написать immutable класс?","Чтоб написать immutable неизменяемый класс, нужно следовать простым пунктам: сделать класс финальным. сделать все поля приватными и создать только геттеры к ним. Сеттеры, разумеется, не нужно. Сделать все mutable поля final, чтобы установить значение можно было только один раз. инициализировать все поля через конструктор, выполняя глубокое копирование (то есть, копируя и сам объект, и его переменные, и переменные переменных, и так далее) клонировать объекты mutable переменных в геттерах, чтобы возвращать только копии значений, а не ссылки на актуальные объекты."));
        questions.add(new Question("Расскажите о коллекции Set и ее реализациях?","Set — это множество уникальных элементов, и это ее главная особенность. То есть Set не допускает повторения одних и тех же элементов."));
        questions.add(new Question("Что такое Exception?","Все исключения делятся на две группы — exceptions и error. Error — используются JVM для отображения ошибок, после которых работа приложения уже не имеет смысла. Например StackOverFlowError, которая говорит, что стек заполнен и программа уже не может работать. Exception — исключения, которые генерируются программно в коде. Есть разные исключения, проверяемые и непроверяемые, но главное, что они есть, и их можно перехватить и продолжить работу приложения."));
        questions.add(new Question("Как программистам обрабатывать исключения?","try-catch-finally — это конструкция, при помощи которой можно правильным образом перехватить и обработать исключение. try — может быть только один раз, в нем и происходит логика; catch — блок, который принимает какой-то тип исключения, их может быть множество. Например, в блоке try будет генерироваться несколько исключений, которые никак друг с другом не связаны; finally — “наконец-то” и этот блок. Это блок, который выполнится в любом случае, независимо от того, что делается в try, catch. throw используют в случае, когда нужно явно создать новое исключение. Применяют его для создания и выбрасывания пользовательских исключений. throws — механизм, при помощи которого метод может выбрасывать одно или более исключений. Добавляются они через запятую."));
        questions.add(new Question("Checked и Unchecked исключения в Java","Checked исключения: Это исключения, которые проверяются во время компиляции. Если какой-то код в методе во время исключения выдает checked исключение, метод обязан либо обработать его при помощи try-catch, либо пробросить его дальше. Unchecked исключения: Это те исключения, которые на этапе компиляции не проверяются. То есть метод может генерировать RuntimeException, а компилятор не напомнит каким-то образом это обработать."));
    }

    @Override
    public Question add(Question question) {
        questions.add(question);
        return question;
    }

    @Override
    public Question remove(Question question) {
        questions.remove(question);
        return question;
    }

    @Override
    public Collection<Question> getAll() {
        return questions;
    }
}
